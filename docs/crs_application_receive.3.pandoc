% crs_application_receive(3)

# NAME

crs_application_receive -- Receiving application messages

# SYNOPSIS

| **#include &lt;croissant.h&gt;**
|
| typedef int
| **crs_application_receive_f**(void \**user_data*, struct crs_node \**node*,
|                           crs_id *src*, crs_id *dest*,
|                           struct crs_message \**msg*);
|
| void
| **crs_application_set_receive**(struct crs_application \**app*,
|                             crs_application_receive_f \**receive*);


# DESCRIPTION

The *receive* callback is how an application instance receives and processes
messages sent over the Pastry overlay network.

When the local node receives a message where it is the final destination (i.e.,
the local node's Pastry identifier is closest to the *dest* identifier for the
message), then the local node extracts the application ID from the message, and
routes the message to the **crs_application**(3) instance that has been
registered with that ID.  The local node then calls that instance's *receive*
callback function.

Your callback should parse the contents of *msg*, using the
**crs_message_decode**(3) family of functions, and then perform whatever logic
is necessary based on the contents of the message.  The *node* parameter is the
**crs_node**(3) instance for the local node.  The *src* and *dest* parameters
are the message's "source" and "destination" Pastry identifiers.  Note that
these don't necessarily correspond to the Pastry identifiers of the sender and
receiver nodes.  The destination identifier will be "close" to the receiver
identifier.  The source identifier will **usually** be the same as the sender
identifier, so that you know where to route any replies to, but this isn't a
requirement.

Your callback can raise an error condition and return a non-zero value.
However, this should only be used in exceptional circumstances, such as an
unexpected parse error, or an error sending a reply message; the underlying
node delivery code that calls your callback won't know how to respond to the
error condition, and so it will just be logged and ignored.  If any real
application-level errors happen, you should catch those and handle them in your
callback â€” possibly by sending an error message back across the overlay network
to the message's sender.
